const code = [
	{ type: 'typescript', content: 'import * as fs from \'fs\';\r\n\r\nenum TokenType {\r\n\tIdentifier = \'identifier\',\r\n\tTerminal = \'terminal\',\r\n\tOperator = \'operator\',\r\n\tTerminator = \'terminator\',\r\n}\r\n\r\ninterface Token {\r\n\ttype: TokenType,\r\n\tvalue: string,\r\n\tposition: number,\r\n}\r\n\r\nenum NodeType {\r\n\tGrammar = \'grammar\',\r\n\tRule = \'rule\',\r\n\tConcatenation = \'concatenation\',\r\n\tAlternation = \'alternation\',\r\n\tFactor = \'factor\',\r\n\tTerm = \'term\',\r\n\tIdentifier = \'identifier\',\r\n\tTerminal = \'terminal\',\r\n}\r\n\r\ninterface Node {\r\n\ttype: NodeType,\r\n\tvalue?: string,\r\n\tposition: number,\r\n\tchildren: Node[],\r\n}\r\n\r\nlet verbose: boolean = false;\r\n\r\nclass Tokenizer {\r\n\tprivate position = 0;\r\n\tprivate tokens: Token[] = [];\t\r\n\t\r\n\tprivate regexPattern: { [key: string]: RegExp } = {\r\n\t\tcomment: \/\\(\\*[^*]*\\*+(?:[^)*][^*]*\\*+)*\\)\/,\r\n\t\twhitespace: \/[ \\t\\n\\r\\f\\b]+\/,\r\n\t\tterminal: \/\".[^\"]*\"|\'.[^\']*\'\/,\r\n\t\tidentifier: \/[A-Za-z][0-9A-Za-z_]*\/,\r\n\t\toperator: \/\\(:|:\\)|\\(|\\\/\\)|[=,\\|\\\/!\\[\\]{}?\\(\\)\\-+*<>]\/,\r\n\t\tterminator: \/[;\\.]\/,\r\n\t};\r\n\r\n\tconstructor(private input: string) {}\r\n\r\n\ttokenize(): Token[] {\r\n\t\tlet remaining = this.input;\r\n\r\n\t\twhile (remaining.length > 0) {\r\n\t\t\tlet matched = false;\r\n\t\t\tthis.position = this.input.length - remaining.length;\r\n\t\t\t\r\n\t\t\tif (this.regexPattern.whitespace.test(remaining)) {\r\n\t\t\t\tconst match = remaining.match(this.regexPattern.whitespace);\r\n\t\t\t\tif (match && match.index === 0) {\r\n\t\t\t\t\tremaining = remaining.substring(match[0].length);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (this.regexPattern.comment.test(remaining)) {\r\n\t\t\t\tconst match = remaining.match(this.regexPattern.comment);\r\n\t\t\t\tif (match && match.index === 0) {\r\n\t\t\t\t\tremaining = remaining.substring(match[0].length);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (this.regexPattern.terminal.test(remaining)) {\r\n\t\t\t\tconst match = remaining.match(this.regexPattern.terminal);\r\n\t\t\t\tif (match && match.index === 0) {\r\n\t\t\t\t\tthis.tokens.push({\r\n\t\t\t\t\t\ttype: TokenType.Terminal,\r\n\t\t\t\t\t\tvalue: match[0],\r\n\t\t\t\t\t\tposition: this.position,\r\n\t\t\t\t\t});\r\n\t\t\t\t\tremaining = remaining.substring(match[0].length);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (this.regexPattern.terminator.test(remaining)) {\r\n\t\t\t\tconst match = remaining.match(this.regexPattern.terminator);\r\n\t\t\t\tif (match && match.index === 0) {\r\n\t\t\t\t\tthis.tokens.push({\r\n\t\t\t\t\t\ttype: TokenType.Terminator,\r\n\t\t\t\t\t\tvalue: match[0],\r\n\t\t\t\t\t\tposition: this.position,\r\n\t\t\t\t\t});\r\n\t\t\t\t\tremaining = remaining.substring(match[0].length);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (this.regexPattern.identifier.test(remaining)) {\r\n\t\t\t\tconst match = remaining.match(this.regexPattern.identifier);\r\n\t\t\t\tif (match && match.index === 0) {\r\n\t\t\t\t\tthis.tokens.push({\r\n\t\t\t\t\t\ttype: TokenType.Identifier,\r\n\t\t\t\t\t\tvalue: match[0],\r\n\t\t\t\t\t\tposition: this.position,\r\n\t\t\t\t\t});\r\n\t\t\t\t\tremaining = remaining.substring(match[0].length);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (this.regexPattern.operator.test(remaining)) {\r\n\t\t\t\tconst match = remaining.match(this.regexPattern.operator);\r\n\t\t\t\tif (match && match.index === 0) {\r\n\t\t\t\t\tthis.tokens.push({\r\n\t\t\t\t\t\ttype: TokenType.Operator,\r\n\t\t\t\t\t\tvalue: match[0],\r\n\t\t\t\t\t\tposition: this.position,\r\n\t\t\t\t\t});\r\n\t\t\t\t\tremaining = remaining.substring(match[0].length);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthrow new Error(`Unexpected token: ${remaining}`);\r\n\t\t}\r\n\r\n\t\treturn this.tokens;\r\n\t}\r\n}\r\n\r\nclass Parser {\r\n\tconstructor(private tokens: Token[]) {}\r\n\t\r\n\tprivate position = 0;\r\n\tprivate ast: Node = {\r\n\t\ttype: NodeType.Grammar,\r\n\t\tposition: 0,\r\n\t\tchildren: [],\r\n\t}\r\n\r\n\tparseError(expected: TokenType, found: Token, expectedValue?: string) {\r\n\t\tthrow `Expected token of type ${expected}${expectedValue ? \" and value of \" + expectedValue : \'\'}, instead found ${found.value} of type ${found.type} at ${found.position}`;\r\n\t}\r\n\r\n\tconsume(tokenType: TokenType, value?: string): Token {\r\n\t\tif (!value) {\r\n\t\t\tif (this.peek().type == tokenType) {\r\n\t\t\t\treturn this.tokens[this.position++];\r\n\t\t\t}\r\n\t\t\tthis.parseError(tokenType, this.peek());\r\n\t\t} else {\r\n\t\t\tif (this.peek().type == tokenType && this.peek().value == value) {\r\n\t\t\t\treturn this.tokens[this.position++];\r\n\t\t\t}\r\n\t\t\tthis.parseError(tokenType, this.peek(), value);\r\n\t\t}\r\n\t\t\t\treturn this.tokens[this.position++];\r\n\t}\r\n\r\n\tpeek(): Token {\r\n\t\treturn this.tokens[this.position];\r\n\t}\r\n\r\n\tparse(): Node {\r\n\t\tthis.ast.children = [] as Node[];\r\n\t\twhile (this.peek()) {\r\n\t\t\tthis.ast.children.push(this.consumeRule());\r\n\t\t}\r\n\t\treturn this.ast;\r\n\t}\r\n\r\n\tconsumeRule(): Node {\r\n\t\tlet lhs: Node = this.consumeIdentifier();\r\n\t\tthis.consume(TokenType.Operator, \'=\');\r\n\t\tlet rhs: Node = this.consumeAlternation();\r\n\t\tthis.consume(TokenType.Terminator);\r\n\t\treturn {\r\n\t\t\ttype: NodeType.Rule,\r\n\t\t\tposition: rhs.position,\r\n\t\t\tchildren: [ lhs, rhs ],\r\n\t\t};\r\n\t}\r\n\r\n\tconsumeIdentifier(): Node {\r\n\t\tlet identifier: Token = this.consume(TokenType.Identifier);\r\n\t\treturn {\r\n\t\t\ttype: NodeType.Identifier,\r\n\t\t\tposition: identifier.position,\r\n\t\t\tvalue: identifier.value,\r\n\t\t\tchildren: [],\r\n\t\t}\r\n\t}\r\n\r\n\tconsumeAlternation(): Node {\r\n\t\tlet concats: Node[] = [];\r\n\t\tconcats.push(this.consumeConcatenation());\r\n\t\twhile (this.peek().value == \'|\') {\r\n\t\t\tthis.consume(TokenType.Operator, \'|\');\r\n\t\t\tconcats.push(this.consumeConcatenation());\r\n\t\t}\r\n\t\treturn {\r\n\t\t\ttype: NodeType.Alternation,\r\n\t\t\tposition: concats[0].position,\r\n\t\t\tchildren: concats,\r\n\t\t}\r\n\t}\r\n\r\n\tconsumeConcatenation(): Node {\r\n\t\tlet factors: Node[] = [];\r\n\t\tfactors.push(this.consumeFactor());\r\n\t\twhile (this.peek().value == \',\') {\r\n\t\t\tthis.consume(TokenType.Operator, \',\');\r\n\t\t\tfactors.push(this.consumeFactor());\r\n\t\t}\r\n\t\treturn {\r\n\t\t\ttype: NodeType.Concatenation,\r\n\t\t\tposition: factors[0].position,\r\n\t\t\tchildren: factors,\r\n\t\t}\r\n\t}\r\n\r\n\tconsumeFactor(): Node {\r\n\t\tlet lhs: Node = this.consumeTerm();\r\n\t\tif ([\'?\', \'*\', \'+\'].includes(this.peek().value)) { \/\/normal operator case\r\n\t\t\tlet operator: Token = this.consume(TokenType.Operator);\r\n\t\t\treturn {\r\n\t\t\t\ttype: NodeType.Factor,\r\n\t\t\t\tposition: lhs.position,\r\n\t\t\t\tvalue: operator.value,\r\n\t\t\t\tchildren: [ lhs ],\r\n\t\t\t}\r\n\t\t} else if (this.peek().value == \'-\') { \/\/exclusion case\r\n\t\t\tthis.consume(TokenType.Operator, \'-\');\r\n\t\t\tlet rhs: Node = this.consumeTerm();\r\n\t\t\treturn {\r\n\t\t\t\ttype: NodeType.Factor,\r\n\t\t\t\tposition: lhs.position,\r\n\t\t\t\tvalue: \'-\',\r\n\t\t\t\tchildren: [ lhs, rhs ],\r\n\t\t\t}\r\n\t\t} else { \/\/just term case\r\n\t\t\treturn {\r\n\t\t\t\ttype: NodeType.Factor,\r\n\t\t\t\tposition: lhs.position,\r\n\t\t\t\tchildren: [ lhs ],\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconsumeTerm(): Node {\r\n\t\tlet token: Token = this.peek();\r\n\t\tlet contents: Node = null as unknown as Node;\r\n\t\tlet value: string = \'\'; \/\/important for determining grouping type\r\n\t\tif (token.value == \'(\') {\r\n\t\t\tthis.consume(TokenType.Operator, \'(\');\r\n\t\t\tcontents = this.consumeAlternation();\r\n\t\t\tthis.consume(TokenType.Operator, \')\');\r\n\t\t\tvalue = \'()\';\r\n\t\t} else if (token.value == \'[\') {\r\n\t\t\tthis.consume(TokenType.Operator, \'[\');\r\n\t\t\tcontents = this.consumeAlternation();\r\n\t\t\tthis.consume(TokenType.Operator, \']\');\r\n\t\t\tvalue = \'[]\';\r\n\t\t} else if (token.value == \'{\') {\r\n\t\t\tthis.consume(TokenType.Operator, \'{\');\r\n\t\t\tcontents = this.consumeAlternation();\r\n\t\t\tthis.consume(TokenType.Operator, \'}\');\r\n\t\t\tvalue = \'{}\';\r\n\t\t} else if (token.type == TokenType.Terminal) { \/\/having things named term terminal and terminator gets confusing\r\n\t\t\tlet term: Token = this.consume(TokenType.Terminal);\r\n\t\t\t\/*let q = term.value[0];\r\n\t\t\tterm.value = q + term.value.slice(1, -1).replace(\/\\\\(n|t|r|b|f|v|u[0-9a-fA-F]{4})\/g, (match, p1) => {\r\n\t\t\t\tswitch(p1) {\r\n\t\t\t\t\tcase \'n\': return \'\\n\';\r\n\t\t\t\t\tcase \'t\': return \'\\t\';\r\n\t\t\t\t\tcase \'r\': return \'\\r\';\r\n\t\t\t\t\tcase \'b\': return \'\\b\';\r\n\t\t\t\t\tcase \'f\': return \'\\f\';\r\n\t\t\t\t\tcase \'v\': return \'\\v\';\r\n\t\t\t\t\tcase \'u\': return String.fromCharCode(parseInt(match.slice(2), 16));\r\n\t\t\t\t\tdefault: return match;\r\n\t\t\t\t}\r\n\t\t\t}) + q;*\/\r\n\t\t\treturn {\r\n\t\t\t\ttype: NodeType.Term,\r\n\t\t\t\tposition: term.position,\r\n\t\t\t\tvalue: \'terminal\',\r\n\t\t\t\tchildren: [{\r\n\t\t\t\t\ttype: NodeType.Terminal,\r\n\t\t\t\t\tposition: term.position,\r\n\t\t\t\t\tvalue: term.value,\r\n\t\t\t\t\tchildren: [],\r\n\t\t\t\t}],\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcontents = this.consumeIdentifier();\r\n\t\t\tvalue = \'identifier\'; \/\/yes yes these should probably be enums somewhere but this is my first ever typescript program and second parser give me some grace buster\r\n\t\t}\r\n\t\treturn {\r\n\t\t\ttype: NodeType.Term,\r\n\t\t\tposition: contents.position,\r\n\t\t\tvalue,\r\n\t\t\tchildren: [ contents ],\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Compiler {\r\n\tprivate rules: { [key: string] : Node } = {};\r\n\r\n\tconstructor(private ast: Node) {};\r\n\r\n\tgetIdentifiers() {\r\n\t\tif (this.ast.type != NodeType.Grammar) throw `huh`;\r\n\t\tfor (let i = 0; i < ast.children.length; i++) {\r\n\t\t\tlet rule: Node = ast.children[i];\r\n\t\t\tif (!rule.children || rule.children.length < 2) throw `blehhh!!`\r\n\t\t\tif (rule.type != NodeType.Rule) throw `thats not good!`;\r\n\t\t\tconst lhs = rule.children[0];\r\n\t\t\tconst rhs = rule.children[1];\r\n\t\t\tif (!lhs.value) throw `rule must have a value`\r\n\t\t\tthis.rules[lhs.value as string] = rhs;\r\n\t\t}\r\n\t}\r\n\t\r\n\tcreateEnums(): string {\t\r\n\t\tthis.getIdentifiers();\r\n\t\tlet compiledEnums: string[] = [];\r\n\t\tcompiledEnums.push(\'enum Type {\');\r\n\t\tfor (let i = 0; i < Object.keys(this.rules).length; i++) {\r\n\t\t\tlet key: string = Object.keys(this.rules)[i];\r\n\t\t\tcompiledEnums.push(`\\t${key} = \'${key}\',`);\r\n\t\t}\r\n\t\tcompiledEnums.push(\'}\\n\\n\');\r\n\t\treturn compiledEnums.join(\"\\n\");\r\n\t}\r\n\r\n\tcreateParser(): string {\r\n\t\tlet compiledParser: string[] = [];\r\n\t\tcompiledParser.push(\"import * as fs from \'fs\'\\n\"); \/\/imports\r\n\r\n\t\tcompiledParser.push(\"type ASTNode = {\"); \/\/ast node\r\n\t\tcompiledParser.push(\"\\ttype: string;\");\r\n\t\tcompiledParser.push(\"\\tvalue: string;\");\r\n\t\tcompiledParser.push(\"\\tchildren: ASTNode[];\")\r\n\t\tcompiledParser.push(\"};\\n\");\r\n\r\n\t\tcompiledParser.push(\'class Parser {\'); \/\/parser class\r\n\t\tcompiledParser.push(\'\\tprivate position: number = 0;\\n\');\r\n\t\tcompiledParser.push(\'\\tconstructor(private input: string) {}\\n\');\r\n\r\n\t\tcompiledParser.push(\'\\tpeek(): string {\'); \/\/peek\r\n\t\tcompiledParser.push(\'\\t\\treturn this.input[this.position]\');\r\n\t\tcompiledParser.push(\'\\t}\\n\');\r\n\r\n\t\tcompiledParser.push(\'\\tconsume(expected: string): ASTNode | null {\'); \/\/consume\r\n\t\tif (verbose) compiledParser.push(\'\\t\\tconsole.log(`attempting to consume ${expected}`)\');\r\n\t\tcompiledParser.push(\'\\t\\tif (this.peek() === expected) {\');\r\n\t\tif (verbose) compiledParser.push(\'\\t\\t\\tconsole.log(`consumed ${expected}`)\');\r\n\t\tcompiledParser.push(\'\\t\\t\\treturn { type: \"TOKEN\", value: this.input[this.position++], children: [] };\');\r\n\t\tcompiledParser.push(\'\\t\\t}\');\r\n\t\tcompiledParser.push(\'\\t\\treturn null;\');\r\n\t\tcompiledParser.push(\'\\t}\\n\');\r\n\r\n\t\tfor (let i = 0; i < Object.keys(this.rules).length; i++) { \/\/rules\r\n\t\t\tlet key: string = Object.keys(this.rules)[i];\r\n\t\t\tcompiledParser.push(...this.createConsumer(key, this.rules[key]));\r\n\t\t}\r\n\t\tlet grammar: string = Object.keys(this.rules)[Object.keys(this.rules).length - 1] as string; \/\/assume last rule defines a grammar\r\n\t\tcompiledParser.push(\'}\\n\');\r\n\r\n\t\tcompiledParser.push(\'const filePath = process.argv[2];\'); \/\/parse\r\n\t\tcompiledParser.push(\'const data = fs.readFileSync(filePath, \"utf-8\");\');\r\n\t\tcompiledParser.push(\'const parser = new Parser(data);\')\r\n\t\tcompiledParser.push(`console.log(JSON.stringify(parser.consume${grammar}()));`);\r\n\t\treturn compiledParser.join(\"\\n\");\r\n\t}\r\n\r\n\tcreateConsumer(identifier: string, rule: Node): string[] {\r\n\t\tlet compiledConsumer: string[] = [];\r\n\t\tcompiledConsumer.push(`\\tconsume${identifier}() {`);\r\n\t\tif (verbose) compiledConsumer.push(`\\t\\tconsole.log(\"attempting to consume ${identifier} at position \" + this.position + \"\")`);\r\n\t\tcompiledConsumer.push(\'\\t\\tlet startPosition = this.position;\'); \/\/incase consumption fails\r\n\t\tcompiledConsumer.push(`\\t\\tlet success: ASTNode | null = ${this.createAlternator(rule)};`);\r\n\t\tcompiledConsumer.push(`\\t\\tif (!success) {`); \/\/if consumption fails\r\n\t\tcompiledConsumer.push(`\\t\\t\\tthis.position = startPosition;`); \/\/if consumption fails\r\n\t\tif (verbose) compiledConsumer.push(`\\t\\t\\tconsole.log(\"could not consume ${identifier}\")`);\r\n\t\tcompiledConsumer.push(`\\t\\t}`)\r\n\t\tcompiledConsumer.push(`\\t\\telse {`)\r\n\t\tcompiledConsumer.push(`\\t\\t\\tsuccess.type = \'${identifier}\'`);\r\n\t\tif (verbose) compiledConsumer.push(`\\t\\t\\tconsole.log(\"consumed ${identifier}\")`);\r\n\t\tcompiledConsumer.push(`\\t\\t}`);\r\n\t\tcompiledConsumer.push(`\\t\\treturn success;`);\r\n\t\tcompiledConsumer.push(\'\\t}\\n\')\r\n\t\treturn compiledConsumer;\r\n\t}\r\n\r\n\tdoNoneOrMore(code: string): string {\r\n\t\treturn \"(()=>{let startPosition = this.position; let acc = []; let res = null; do {res = \" + code + \"; if (res) acc.push(res)} while (res); return { type: \'matcher\', value: \'0+\', children: acc};})()\";\r\n\t}\r\n\r\n\tdoOnceOrMore(code: string): string {\r\n\t\treturn \"(()=>{let startPosition = this.position; let acc = []; let res = \" + code + \"; if (!res) {this.position = startPosition; return null;} while(res){acc.push(res); res = \" + code + \"}; return { type: \'matcher\', value: \'1+\', children: acc};})()\"; \r\n\t}\r\n\r\n\tdoNoneOrOnce(code: string): string {\r\n\t\treturn \"(()=>{let startPosition = this.position; let res = \" + code + \"; if (!res) {this.position = startPosition; return { type: \'matcher\', value: \'0|1\', children: []};} return { type: \'matcher\', value: \'0|1\', children: [res]};})()\";\r\n\t}\r\n\r\n\texcludeFrom(code: string, excludes: string): string {\r\n\t\treturn \"(() => {let startPosition = this.position; let res = \" + excludes + \"; this.position = startPosition; if (res) {return null} else {return \" + code + \"}})()\";\r\n\t}\r\n\r\n\tcreateAlternator(alternator: Node): string {\r\n\t\tlet compiledAlternator: string = \"let startPosition = this.position; let res = null; \";\r\n\t\tif (alternator.type != NodeType.Alternation) throw `huhhh`;\r\n\t\tif (alternator.children.length == 1) return this.createConcatenator(alternator.children[0]);\r\n\t\tfor (let i = 0; i < alternator.children.length; i++) {\r\n\t\t\tcompiledAlternator += \"res = (\" + this.createConcatenator(alternator.children[i]) + \"); if (res) {return res;}\";\r\n\t\t\t\/*if (i + 1 < alternator.children.length) {\r\n\t\t\t\tcompiledAlternator += \" || \";\r\n\t\t\t}*\/\r\n\t\t}\r\n\t\treturn \"(()=>{\" + compiledAlternator + \"})()\";\r\n\t}\r\n\r\n\tcreateConcatenator(concatenator: Node): string {\r\n\t\tlet compiledConcatenator: string = \"let startPosition = this.position; let acc = []; let res = null; \";\r\n\t\tif (concatenator.type != NodeType.Concatenation) throw `expected concatenator...`;\r\n\t\tif (concatenator.children.length == 1) return this.createFactor(concatenator.children[0]);\r\n\t\tfor (let i = 0; i < concatenator.children.length; i++) {\r\n\t\t\tcompiledConcatenator += \"res = \" + this.createFactor(concatenator.children[i]) + \"; if (!res) {this.position = startPosition; return null} acc.push(res); \"\r\n\t\t\t\/*if (i + 1 < concatenator.children.length) {\r\n\t\t\t\tcompiledConcatenator += \" && \";\r\n\t\t\t}*\/\r\n\t\t}\r\n\t\tcompiledConcatenator += \"return { type: \'concat\', value: \'\', children: acc};\"\r\n\t\treturn \"(()=>{\" + compiledConcatenator + \"})()\";\r\n\t}\r\n\r\n\tcreateFactor(factor: Node): string {\r\n\t\tlet compiledFactor: string = \"\";\r\n\t\tif (factor.type != NodeType.Factor) throw `expected factor...`;\r\n\t\tif (!factor.value) { \/\/no operaton to be performed\r\n\t\t\tcompiledFactor += this.createTerm(factor.children[0]);\r\n\t\t} else if (factor.value == \"*\") {\r\n\t\t\tcompiledFactor += this.doNoneOrMore(this.createTerm(factor.children[0]));\r\n\t\t} else if (factor.value == \"+\") {\r\n\t\t\tcompiledFactor += this.doOnceOrMore(this.createTerm(factor.children[0]));\r\n\t\t} else if (factor.value == \"?\") {\r\n\t\t\tcompiledFactor += this.doNoneOrOnce(this.createTerm(factor.children[0]));\r\n\t\t} else if (factor.value == \"-\") {\r\n\t\t\tcompiledFactor += this.excludeFrom(this.createTerm(factor.children[0]), this.createTerm(factor.children[1]));\r\n\t\t} else {\r\n\t\t\tthrow `unknown factor ${factor.value}`;\r\n\t\t}\r\n\t\treturn compiledFactor;\r\n\t}\r\n\r\n\tcreateTerm(term: Node): string {\r\n\t\tlet compiledTerm: string = \"\";\r\n\t\tif (term.value == \"identifier\") {\r\n\t\t\tcompiledTerm += this.createIdentifier(term.children[0]);\r\n\t\t} else if (term.value == \"terminal\") {\r\n\t\t\tcompiledTerm += this.createTerminal(term.children[0]);\r\n\t\t} else if (term.value == \"[]\") {\r\n\t\t\tcompiledTerm += this.doNoneOrOnce(this.createAlternator(term.children[0]));\r\n\t\t} else if (term.value == \"()\") {\r\n\t\t\tcompiledTerm += \"(\" + this.createAlternator(term.children[0]) + \")\";\r\n\t\t} else if (term.value == \"{}\") {\r\n\t\t\tcompiledTerm += this.doNoneOrMore(this.createAlternator(term.children[0]));\r\n\t\t} else {\r\n\t\t\tthrow `unknown term ${term.value}`;\r\n\t\t}\r\n\t\treturn compiledTerm;\r\n\t}\r\n\r\n\tcreateIdentifier(identifier: Node): string {\r\n\t\treturn `this.consume${identifier.value}()`;\r\n\t}\r\n\r\n\tcreateTerminal(terminal: Node): string {\r\n\t\treturn `this.consume(${terminal.value})`;\r\n\t}\r\n\r\n\tcompile(): string {\r\n\t\tlet compileString: string = \'\';\r\n\t\tcompileString += this.createEnums();\r\n\t\tcompileString += this.createParser();\r\n\t\treturn compileString;\r\n\t}\r\n\r\n\tcompileToFile(filePath: string) {\r\n\t\tfs.writeFileSync(filePath, this.compile(), \'utf8\');\r\n\t}\r\n}\r\n\r\nconst filePath = process.argv[2];\r\nconst data = fs.readFileSync(filePath, \'utf-8\');\r\n\r\nconst tokenizer = new Tokenizer(data);\r\nconst tokens = tokenizer.tokenize();\r\nconst parser = new Parser(tokens);\r\nconst ast = parser.parse();\r\nconst compiler = new Compiler(ast);\r\nconst compiled = compiler.compile();\r\ncompiler.compileToFile(\"dist\/compiled.ts\");\r\n\r\nif (verbose) {\r\n\tconsole.log(tokens);\r\n\tconsole.log(JSON.stringify(ast));\r\n\tconsole.log(compiled);\r\n}'},
	{ type: 'c', content: '#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <ncurses.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include \"constants.h\"\r\n#include <ctype.h>\r\n#include \"tabUtil.h\"\r\n\r\nconst char *MODES[] = {\"COMMAND\", \"EDIT\", \"REPLACE\"};\r\nchar *EXTS[] = {\r\n\t\"js\",\r\n\t\"c\",\r\n\t\"html\",\r\n\t\"txt\",\r\n\t\"cpp\",\r\n\t\"ua\",\r\n\t\"py\",\r\n\t\"h\",\r\n\t\"css\",\r\n\t\"svg\",\r\n\t\"md\",\r\n\t\"csv\",\r\n\t\"log\",\r\n\t\"xml\",\r\n\t\"json\",\r\n\t\"yaml\",\r\n\t\"yml\",\r\n\t\"ini\",\r\n\t\"java\",\r\n\t\"ts\",\r\n\t\"sh\",\r\n\t\"bat\",\r\n\tNULL, \/\/terminate list or some shit idk im lazy\r\n};\r\nchar *FORMATS[] = {\r\n\t\"Javascript\",\r\n\t\"C\",\r\n\t\"Hypertext Markup Language\",\r\n\t\"Text\",\r\n\t\"C++\",\r\n\t\"Uiua\",\r\n\t\"Python\",\r\n\t\"C Header\",\r\n\t\"Cascading Style Sheets\",\r\n\t\"Scalable Vector Graphics\",\r\n\t\"Markdown\",\r\n\t\"Comma-Separated Values\",\r\n\t\"Log\",\r\n\t\"XML\",\r\n\t\"JSON\",\r\n\t\"YAML\",\r\n\t\"YAML\",\r\n\t\"INI Configuration\",\r\n\t\"Java Source\",\r\n\t\"Typescript\",\r\n\t\"Shell Script\",\r\n\t\"Batch\",\r\n\tNULL,\r\n};\r\n\r\nint max(int a, int b) {\r\n\treturn a > b ? a : b;\r\n}\r\n\r\nint min(int a, int b) {\r\n\treturn a < b ? a : b;\r\n}\r\n\r\nchar** readFileToCharArray(FILE* file, int* numLines, int* numChars) {\r\n\tint charCount = 0;\r\n\tint linesCount = 0;\r\n\tint lineCount = 0;\r\n\t\r\n\tsize_t linesSize = LINES_BUFFER_MIN;\r\n\tchar** lines = malloc(linesSize * sizeof(char*));\r\n\tsize_t lineSize = LINE_BUFFER_MIN;\r\n\tchar* line = malloc(lineSize * sizeof(char));\r\n\r\n\tint ch;\r\n\twhile ((ch = fgetc(file)) || 1) { \/\/read file character by character (avoid max line length)\r\n\t\tint newLine = ch == \'\\n\';\r\n\t\tint eof = ch == EOF;\r\n\t\tif (lineSize - 1 <= lineCount) { \/\/resize line\r\n\t\t\tlineSize *= 2;\r\n\t\t\tline = realloc(line, lineSize * sizeof(char));\r\n\t\t}\r\n\r\n\t\tline[lineCount] = ch; \/\/add char\r\n\t\tlineCount++;\r\n\r\n\t\tif (newLine || eof) { \/\/increment lines buffers\r\n\t\t\tline[lineCount] = \'\\0\'; \/\/terminate line\r\n\t\t\tif (linesSize - 1 <= linesCount) { \/\/resize lines\r\n\t\t\t\tlinesSize *= 2;\r\n\t\t\t\tlines = realloc(lines, linesSize * sizeof(char*));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlines[linesCount] = line;\r\n\t\t\tlinesCount++;\r\n\t\t\t\r\n\t\t\tif (eof) break;\r\n\r\n\t\t\tlineSize = LINE_BUFFER_MIN;\r\n\t\t\tline = malloc(lineSize * sizeof(char)); \/\/start new line\r\n\t\t\tcharCount += lineCount;\r\n\t\t\tlineCount = 0;\r\n\t\t}\r\n\t}\r\n\t*numLines = linesCount - 1;\r\n\t*numChars = charCount - 1;\r\n\treturn lines;\r\n}\r\n\r\nvoid writeLinesToFile(char* filename, char* lines[], int lineCount) {\r\n\tFILE* file = fopen(filename, \"w\");\r\n\tfor (int i = 0; i < lineCount; i++) {\r\n\t\tif (fputs(lines[i], file) == EOF) {\r\n\t\t\tfclose(file);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tfclose(file);\r\n}\r\n\r\nvoid insertChar(char** str, char ch, int index) {\r\n\tint len = strlen(*str);\r\n\tif (index > len) {\r\n\t\tindex = len;\r\n\t}\r\n\r\n\tchar *newStr = realloc(*str, len + 2); \/\/ +1 for ch +1 for \\0\r\n\t*str = newStr;\r\n\r\n\tmemmove(&(*str)[index + 1], &(*str)[index], len - index + 1);\r\n\t(*str)[index] = ch;\r\n}\r\n\r\nvoid insertLine(char*** lines, int* linesCount, int line, int col) {\r\n\tif (line > *linesCount) {\r\n\t\tline = *linesCount;\r\n\t}\r\n\r\n\t*lines = realloc(*lines, (*linesCount + 1) * sizeof(char*));\r\n\tint lineCount = strlen((*lines)[line]);\r\n\r\n\tfor (int i = *linesCount; i > line; i--) { \r\n\t\t(*lines)[i] = (*lines)[i - 1];\r\n\t}\r\n\r\n\tchar* newLine = malloc(lineCount - col + 1);\r\n\tstrcpy(newLine, &(*lines)[line][col]);\r\n\r\n\t(*lines)[line] = realloc((*lines)[line], col + 2);\r\n\t(*lines)[line][col] = \'\\n\';\r\n\t(*lines)[line][col + 1] = \'\\0\';\r\n\r\n\t(*lines)[line+1] = newLine;\r\n\r\n\t(*linesCount)++;\r\n}\r\n\r\nvoid removeChar(char** str, int index) {\r\n\tint len = strlen(*str);\r\n\tif (index >= len) {\r\n\t\tindex = len - 1;\r\n\t}\r\n\tif (index < 0) return;\r\n\r\n\tmemmove(&(*str)[index], &(*str)[index + 1], len - index);\r\n}\r\n\r\nvoid removeNewline(char*** lines, int* linesCount, int line) {\r\n\tif (line == 0) return; \/\/cannot move line to -1\r\n\r\n\tsize_t prevLen = strlen((*lines)[line - 1]);\r\n\tsize_t currLen = strlen((*lines)[line]);\r\n\r\n\t(*lines)[line - 1][prevLen - 1] = \'\\0\'; \/\/remove newline\r\n\tprevLen--;\r\n\t\r\n\t(*lines)[line - 1] = realloc((*lines)[line - 1], prevLen + currLen + 1);\r\n\tstrcat((*lines)[line - 1], (*lines)[line]);\r\n\r\n\tfree((*lines)[line]);\r\n\r\n\tfor (int i = line; i < *linesCount - 1; i++) {\r\n\t\t(*lines)[i] = (*lines)[i + 1];\r\n\t}\r\n\r\n\r\n\t(*linesCount)--;\r\n}\r\n\r\nint indexOf(char** strings, int numStrings, char* str) {\r\n\tfor (int i = 0; i < numStrings && strings[i] != NULL; i++) {\r\n\t\tif (strcmp(strings[i], str) == 0) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nchar* getExtensionFromFilename(char* filename) {\r\n\tint len = strlen(filename);\r\n\tfor (int i = len - 1; i >= 0; i--) {\r\n\t\tif (filename[i] == \'.\') {\r\n\t\t\tif (i < len - 1) {\r\n\t\t\t\treturn &filename[i + 1];\r\n\t\t\t} else {\r\n\t\t\t\treturn NULL; \/\/case of \"file.\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn NULL; \/\/no extension\r\n}\r\n\r\nint getTabCount(char *str) {\r\n\tint len = strlen(str);\r\n\tfor (int i = 0; i < len; i++) {\r\n\t\tif (str[i] != \'\\t\') {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn len;\r\n}\r\n\r\nvoid quit(FILE* file) {\r\n\tfclose(file);\r\n\tendwin();\r\n\texit(0);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n\r\n\tif (argc < 2) {\r\n\t\tprintf(\"Please provide a filename to edit\\n\");\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t\/\/find file\r\n\tchar *targetFileName = argv[1];\r\n\tchar *targetFileExt = getExtensionFromFilename(targetFileName);\r\n\tchar *targetFileType;\r\n\ttargetFileType = NULL;\r\n\tif (targetFileExt != NULL) {\r\n\t\tint index = indexOf(EXTS, 1e4, targetFileExt);\r\n\t\ttargetFileType = FORMATS[index];\r\n\t}\r\n\tFILE *targetFile = fopen(targetFileName, \"r+\"); \/\/open file for reading\/writing\r\n\tif (targetFile == NULL) {\r\n\t\tprintf(\"Unable to locate file %s\\n\", targetFileName);\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\t\/\/read file\r\n\tint linesCount;\r\n\tint charsCount;\r\n\tchar **fileContents = readFileToCharArray(targetFile, &linesCount, &charsCount);\r\n\tif (linesCount == 0 && charsCount == -1) { \/\/completely empty file case\r\n\t\tstrcpy(fileContents[0], \"\\n\");\r\n\t\tcharsCount++;\r\n\t\tlinesCount++;\r\n\t}\r\n\r\n\t\/\/initialize ncurses\r\n\tinitscr();\r\n\tnoecho();\r\n\tcbreak();\r\n\tkeypad(stdscr, 1);\r\n\tcurs_set(0);\r\n\tset_escdelay(25);\r\n\r\n\t\/\/initialize colors\r\n\tint colorMode = has_colors();\r\n\tif (colorMode) {\r\n\t\tstart_color();\r\n\t\tinit_pair(COLOR_BW, COLOR_BLACK, COLOR_WHITE);\r\n\t\tinit_pair(COLOR_GRAY, 8, COLOR_BLACK);\r\n\t\tinit_pair(COLOR_COM, COLOR_GREEN, COLOR_BLACK);\r\n\t\tinit_pair(COLOR_REP, COLOR_WHITE, COLOR_WHITE);\r\n\t}\r\n\t\r\n\t\/\/initialize screen info\r\n\tint screenWidth, screenHeight;\r\n\tint line = 0;\r\n\tint goalCol = 0;\r\n\tint colDisp = 0;\r\n\tint colActual = 0;\r\n\tgetmaxyx(stdscr, screenHeight, screenWidth);\r\n\twchar_t input = 0;\r\n\tint scroll = 0;\r\n\tint MODE = 0;\r\n\tint SUCCESSFUL_WRITE = 0;\r\n\r\n\t\/\/main loop\r\n\tdo {\r\n\t\terase();\r\n\t\tgetmaxyx(stdscr, screenHeight, screenWidth);\r\n\t\t\r\n\t\tint lineW = (int) log10((double) linesCount) + 2; \/\/make room for line numbers\r\n\t\t\r\n\t\tswitch (input) {\r\n\t\t\tcase KEY_LEFT:\r\n\t\t\t\tcolActual--;\r\n\t\t\t\tif (fileContents[line][colActual] != \'\\t\') {\r\n\t\t\t\t\tcolDisp--;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcolDisp = tab_strlenFrom(fileContents[line], 0, colActual);\r\n\t\t\t\t}\r\n\t\t\t\tgoalCol = colDisp;\r\n\t\t\t\tbreak;\r\n\t\t\tcase KEY_RIGHT:\r\n\t\t\t\tif (fileContents[line][colActual] != \'\\t\') {\r\n\t\t\t\t\tcolDisp++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcolDisp = tab_strlenFrom(fileContents[line], 0, colActual + 1);\r\n\t\t\t\t}\r\n\t\t\t\tcolActual++;\r\n\t\t\t\tgoalCol = max(colDisp, goalCol);\r\n\t\t\t\tbreak;\r\n\t\t\tcase KEY_UP:\r\n\t\t\t\tif (line > 0) {\r\n\t\t\t\t\tline--;\r\n\t\t\t\t\tcolActual = tab_strlenTo(fileContents[line], 0, goalCol);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcolActual = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase KEY_DOWN:\r\n\t\t\t\tif (line < linesCount - 1) {\r\n\t\t\t\t\tline++;\r\n\t\t\t\t\tcolActual = tab_strlenTo(fileContents[line], 0, goalCol);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcolActual = strlen(fileContents[line]);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase KEY_PPAGE:\r\n\t\t\t\tline -= screenHeight;\r\n\t\t\t\tbreak;\r\n\t\t\tcase KEY_NPAGE:\r\n\t\t\t\tline += screenHeight;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 27: \/\/esc\r\n\t\t\t\tMODE = COMMAND_MODE;\r\n\t\t}\r\n\r\n\t\tswitch (MODE) {\r\n\t\t\tcase COMMAND_MODE:\r\n\t\t\t\tswitch (input) {\r\n\t\t\t\t\tcase \'e\':\r\n\t\t\t\t\t\tMODE = EDIT_MODE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \'r\':\r\n\t\t\t\t\t\tMODE = REPLACE_MODE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \'q\':\r\n\t\t\t\t\t\tquit(targetFile);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \'w\':\r\n\t\t\t\t\t\twriteLinesToFile(targetFileName, fileContents, linesCount);\r\n\t\t\t\t\t\tSUCCESSFUL_WRITE = 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase EDIT_MODE:\r\n\t\t\t\tswitch (input) {\r\n\t\t\t\t\tcase KEY_BACKSPACE:\r\n\t\t\t\t\t\tif (colActual != 0) {\r\n\t\t\t\t\t\t\tremoveChar(&fileContents[line], colActual - 1);\r\n\t\t\t\t\t\t\tcolActual--;\r\n\t\t\t\t\t\t\tcharsCount--;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (line > 0) {\r\n\t\t\t\t\t\t\t\tcolActual = strlen(fileContents[line - 1]) - 1;\r\n\t\t\t\t\t\t\t\tremoveNewline(&fileContents, &linesCount, line);\r\n\t\t\t\t\t\t\t\tline--;\r\n\t\t\t\t\t\t\t\tcharsCount--;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase KEY_DC:\r\n\t\t\t\t\t\tif (colActual < strlen(fileContents[line]) - 1) {\r\n\t\t\t\t\t\t\tremoveChar(&fileContents[line], colActual);\r\n\t\t\t\t\t\t\tcharsCount--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \'\\n\':\r\n\t\t\t\t\t\tinsertLine(&fileContents, &linesCount, line, colActual);\r\n\t\t\t\t\t\tint tabs = getTabCount(fileContents[line]); \/\/get tabs of previous line\r\n\t\t\t\t\t\tline++;\r\n\t\t\t\t\t\tcharsCount++;\r\n\t\t\t\t\t\tfor (int i = 0; i < tabs; i++) {\r\n\t\t\t\t\t\t\tinsertChar(&fileContents[line], \'\\t\', i);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcolActual = tabs;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (isprint(input) || input == \'\\t\') {\r\n\t\t\t\t\tinsertChar(&fileContents[line], input, colActual);\r\n\t\t\t\t\tcolActual++;\r\n\t\t\t\t\tcharsCount++;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase REPLACE_MODE: \/\/no idea why you would use this an stackoverflow doesnt really know either but oh well\r\n\t\t\t\tswitch (input) {\r\n\t\t\t\t\tcase KEY_BACKSPACE:\r\n\t\t\t\t\t\tcolActual--;\r\n\t\t\t\t\t\tcolActual = max(colActual, 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (isprint(input)) {\r\n\t\t\t\t\tif (colActual < strlen(fileContents[line]) - 1) {\r\n\t\t\t\t\t\tremoveChar(&fileContents[line], colActual);\r\n\t\t\t\t\t\tcharsCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinsertChar(&fileContents[line], input, colActual);\r\n\t\t\t\t\tcolActual++;\r\n\t\t\t\t\tcharsCount++;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t\/\/bound cursor\r\n\t\tint displayRowStart = 1; \/\/make room for file banner\r\n\t\tline = max(0, line);\r\n\t\tline = min(line, linesCount - 1);\r\n\t\tcolActual = min(colActual, strlen(fileContents[line]) - 1);\r\n\t\tcolActual = max(0, colActual);\r\n\t\tcolDisp = tab_strlenFrom(fileContents[line], 0, colActual);\r\n\t\tcolActual = tab_strlenTo(fileContents[line], 0, colDisp);\r\n\r\n\t\tif (line - scroll >= screenHeight - displayRowStart - SCROLL_PADDING) {\r\n\t\t\tscroll = min(line - (screenHeight - displayRowStart - SCROLL_PADDING), linesCount - 1);\r\n\t\t}\r\n\t\tif (line - scroll < SCROLL_PADDING) {\r\n\t\t\tscroll = max(line - SCROLL_PADDING, 0);\r\n\t\t}\r\n\r\n\t\t\/\/render file text\r\n\t\tint linesUntil = screenHeight - displayRowStart;\r\n\t\tfor (int i = 0; i < linesUntil; i++) {\r\n\t\t\tint currentLine = i + scroll;\r\n\t\t\tint displayCol = lineW;\r\n\t\t\tint currentRow = i + displayRowStart;\r\n\t\t\tif (currentLine < linesCount) {\r\n\t\t\t\ttab_mvprintw(currentRow, displayCol, lineW, \"%.*s\", screenWidth - lineW, fileContents[currentLine]);\t\r\n\t\t\t\tattron(COLOR_PAIR(COLOR_GRAY));\r\n\t\t\t\tmvprintw(currentRow, 0, \"%*d \", lineW - 1, currentLine + 1);\r\n\t\t\t\tattroff(COLOR_PAIR(COLOR_GRAY));\r\n\t\t\t} else {\r\n\t\t\t\tattron(COLOR_PAIR(COLOR_GRAY));\r\n\t\t\t\tmvprintw(currentRow, displayCol, \"~\");\r\n\t\t\t\tattroff(COLOR_PAIR(COLOR_GRAY));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t\/\/render file banner\r\n\t\tint bannerRow = 0;\r\n\t\tattron(COLOR_PAIR(COLOR_BW));\r\n\t\tfor (int i = 0; i < screenWidth; i++) {\r\n\t\t\tchar fillChar = colorMode ? \' \' : 183; \/\/if color not supported use middle dot\r\n\t\t\tmvaddch(bannerRow, i, fillChar);\r\n\t\t}\r\n\t\tif (targetFileType != NULL) {\r\n\t\t\tmvprintw(bannerRow, 0, \"WTE\\t%s\\t%s File\\t%dL\\t%dC\", targetFileName, targetFileType, linesCount, charsCount);\r\n\t\t} else if (targetFileExt != NULL) {\r\n\t\t\tmvprintw(bannerRow, 0, \"WTE\\t%s\\t%s File\\t%dL\\t%dC\", targetFileName, targetFileExt, linesCount, charsCount);\r\n\t\t} else {\r\n\t\t\tmvprintw(bannerRow, 0, \"WTE\\t%s\\t\\t%dL\\t%dC\", targetFileName, linesCount, charsCount);\r\n\t\t}\r\n\t\tmvprintw(bannerRow, screenWidth-24, \"\\t%d\\t%d-%d\", line, colDisp, colActual);\r\n\t\tattroff(COLOR_PAIR(COLOR_BW));\r\n\r\n\t\t\/\/render command banner\r\n\t\tint commandRow = screenHeight - 1;\r\n\t\tattron(COLOR_PAIR(COLOR_COM));\r\n\t\tfor (int i = 0; i < screenWidth; i++) {\r\n\t\t\tchar fillChar = colorMode ? \' \' : 183; \/\/if color not supported use middle dot\r\n\t\t\tmvaddch(commandRow, i, fillChar);\r\n\t\t}\r\n\t\tif (SUCCESSFUL_WRITE) {\r\n\t\t\tmvprintw(commandRow, 0, \"-- WRITE SUCCESSFUL --\");\r\n\t\t\tSUCCESSFUL_WRITE = 0;\t\r\n\t\t} else {\r\n\t\t\tmvprintw(commandRow, 0, \"== %s MODE ==\", MODES[MODE]);\t\r\n\t\t}\r\n\t\tattroff(COLOR_PAIR(COLOR_COM));\r\n\r\n\t\trefresh();\r\n\r\n\t\t\/\/display cursor\r\n\t\tint cursorRow = line + displayRowStart - scroll;\r\n\t\tint cursorCol = colDisp + lineW;\r\n\t\tif (MODE != REPLACE_MODE) {\r\n\t\t\tcurs_set(1);\r\n\t\t\tmove(cursorRow, cursorCol);\r\n\t\t} else {\r\n\t\t\tcurs_set(0);\r\n\t\t\tattron(COLOR_PAIR(COLOR_REP));\r\n\t\t\tmvaddch(cursorRow, cursorCol, \' \');\r\n\t\t\tattroff(COLOR_PAIR(COLOR_REP));\r\n\t\t}\r\n\r\n\t\tinput = getch();\r\n\t} while (1);\r\n\tquit(targetFile);\r\n\treturn 0;\r\n}}'},
	{ type: 'asm', content: 'section .data\r\n\t; camera position\r\n\tcam_pos: dd 0.0, 0.0, 0\r\n\r\n\t; sphere position\r\n\tsp_pos: dd 7.5, 7.5, 7.5\r\n\tsp_rad: dd 5.0\r\n\r\n\t; ray distance\r\n\tray_dst: dd 0.0\r\n\r\n\t; iterations\r\n\titerations: dw 50\r\n\ti_count: dw 0\r\n\r\n\t; space wrap\r\n\tspace_wrap: dd 15.0\r\n\r\n\t; looping\r\n\tcurrent_row: dw 0\r\n\tcurrent_col: dw 0\r\n\r\n\t; screen size\r\n\tsc_col: dw 0\r\n\tsc_row: dw 0\r\n\r\n\t; float screen size\r\n\tsc_colf: dd 0.0\r\n\tsc_rowf: dd 0.0\r\n\r\n\tzero: dd 0.0\r\n\tone: dd 1.0\r\n\thalf: dd 0.5\r\n\ttwo: dd 2.0\r\n\r\n\tepsilon: dd 0.001\r\n\r\n\tshading_max: dd 6.0\r\n\r\n\tshading_min: dd 1.0\r\n\r\n\twhmsg db \'Screen width: %u  Screen height: %u\', 10, 0\r\n\r\n\t;shading db \'.\', 0\r\n\r\n\tray_debug db \'%f,%f,%f\', 10, 0\r\n\r\n\tsdf_debug db \'sdf: %f\', 10, 0\r\n\r\n\tshading db \' #x*+-.\'\r\n\tshadingf db \'%c\', 0\r\n\r\n\tshading_debug db \'ray_dst: %f\', 10, 0\r\n\r\nsection .bss\r\n\tsz resw 4\r\n\r\n\t; ray stuff\r\n\tray_pos resd 3\r\n\tray_dir resd 3\r\n\r\nsection .text\r\nglobal _start\r\nextern printf, exit, malloc\r\n\r\n_start:\r\n\r\n\tmov eax, 16 ; sys_ioctl call\r\n\tmov edi, 1\r\n\tmov esi, 0x5413\r\n\tmov edx, sz\r\n\tsyscall\r\n\r\n\tmovzx rsi, WORD [sz+2]\r\n\tmovzx rdi, WORD [sz+0]\r\n\r\n\tmov WORD [sc_col], si\r\n\tmov WORD [sc_row], di\r\n\r\n\tmov rdi, whmsg ; print screen size using printf\r\n\tmovzx rsi, WORD [sc_col]\r\n\tmovzx rdx, WORD [sc_row]\r\n\txor eax, eax\r\n\tcall printf\r\n\r\n\t; get float screen size\r\n\tmovzx eax, WORD [sc_col]\r\n\tcvtsi2ss xmm0, eax\r\n\tmovss [sc_colf], xmm0\r\n\tmovzx eax, WORD [sc_row]\r\n\tcvtsi2ss xmm0, eax\r\n\tmovss [sc_rowf], xmm0\r\n\r\n\t; initialize row loop\r\n\tmov ax, WORD [sc_row]\r\n\tmov [current_row], ax\r\n\r\ndo_row:\r\n\t\r\n\t; initialize col loop\r\n\tmov ax, WORD [sc_col]\r\n\tmov [current_col], ax\r\n\r\n\tcall do_col\r\n\t\r\n\tdec WORD [current_row] ; dec row counter\r\n\tcmp WORD [current_row], 0\r\n\tja do_row\r\n\r\n\txor edi, edi\r\n\tcall exit\r\n\r\ndo_col:\r\n\r\n\tcall cast_ray\r\n\r\n\t;mov rdi, shading\r\n\t;xor eax, eax\r\n\t;call printf\r\n\r\n\tdec WORD [current_col] ; dec col counter\r\n\tcmp WORD [current_col], 0\r\n\tja do_col\r\n\r\n\tret\r\n\r\ncast_ray:\r\n\r\n\tmovss xmm0, [zero] ; reset ray_dst\r\n\tmovss [ray_dst], xmm0\r\n\t\r\n\tmovzx eax, WORD [current_col]\r\n\tcvtsi2ss xmm0, eax ; convert col to float\r\n\tmovss [ray_dir], xmm0 ; store col\r\n\r\n\tmovzx eax, WORD [current_row]\r\n\tcvtsi2ss xmm0, eax\r\n\tmovss [ray_dir+4], xmm0 ; store row\r\n\r\n\tmovss xmm0, [one]\r\n\tmovss [ray_dir+8], xmm0\r\n\r\n\t; align ray direction\r\n\tmovss xmm1, [sc_colf] ; align col\r\n\tmovss xmm0, [ray_dir]\r\n\tmulss xmm1, [half] ; divide col by 2\r\n\tsubss xmm0, xmm1 ; c-col\/2\r\n\tmulss xmm0, [two] ; 2*(c-col\/2)\r\n\tdivss xmm0, [sc_colf]\r\n\tmovss [ray_dir], xmm0\r\n\r\n\tmovss xmm1, [sc_rowf] ; align row\r\n\tmovss xmm0, [ray_dir+4]\r\n\tmulss xmm1, [half] ; divide row by 2\r\n\tsubss xmm0, xmm1 ; r-row\/2\r\n\tmulss xmm0, [two] ; 2*(r-row\/2)\r\n\tdivss xmm0, [sc_rowf]\r\n\tmovss [ray_dir+4], xmm0\r\n\r\n\t; normalize ray\r\n\tmovss xmm0, [ray_dir]\r\n\tmulss xmm0, xmm0\r\n\tmovss xmm1, [ray_dir+4]\r\n\tmulss xmm1, xmm1\r\n\taddss xmm0, xmm1\r\n\tmovss xmm1, [ray_dir+8]\r\n\tmulss xmm1, xmm1\r\n\taddss xmm0, xmm1\r\n\r\n\tsqrtss xmm0, xmm0\r\n\r\n\tmovss xmm1, [ray_dir]\r\n\tdivss xmm1, xmm0\r\n\tmovss [ray_dir], xmm1\r\n\r\n\tmovss xmm1, [ray_dir+4]\r\n\tdivss xmm1, xmm0\r\n\tmovss [ray_dir+4], xmm1\r\n\r\n\tmovss xmm1, [ray_dir+8]\r\n\tdivss xmm1, xmm0\r\n\tmovss [ray_dir+8], xmm1\r\n\r\n\tmovss xmm0, [cam_pos] ; initialize ray to camera\r\n\tmovss [ray_pos], xmm0\r\n\tmovss xmm0, [cam_pos+4]\r\n\tmovss [ray_pos+4], xmm0\r\n\tmovss xmm0, [cam_pos+8]\r\n\tmovss [ray_pos+8], xmm0\r\n\t\r\n\tmov WORD [i_count], 0\r\n\r\nmarch_ray_loop:\r\n\r\n\tcall march_ray\r\n\tinc WORD [i_count]\r\n\tmovzx eax, WORD [iterations]\r\n\tcmp WORD [i_count], ax\r\n\tjb march_ray_loop\r\n\r\n\tcall get_sdf\r\n\r\n\tucomiss xmm0, [epsilon] ; check for hit\r\n\tjb ray_hit\r\n\tjnb ray_nothit\r\n\r\nray_hit:\r\n\r\n\tmovss xmm0, [ray_dst]\r\n\tdivss xmm0, [two]\r\n\tdivss xmm0, [two]\r\n\tdivss xmm0, [two]\r\n\tminss xmm0, [shading_max]\r\n\tmaxss xmm0, [shading_min]\r\n\txor rax, rax\r\n\tcvttss2si eax, xmm0\r\n\tmov rcx, rax\r\n\t\r\n\t;mov rcx, 5\r\n\tjmp shade_ray\r\n\r\nray_nothit:\r\n\r\n\tmov rcx, 0\r\n\tjmp shade_ray\r\n\r\nshade_ray:\r\n\r\n\t; index shading by rcx\r\n\tmov rdi, shadingf\r\n\txor eax, eax\r\n\tmov rsi, shading\r\n\tadd rsi, rcx\r\n\tmov al, byte [rsi]\r\n\tmovzx rsi, al\r\n\tcall printf\r\n\t\r\n\t; debug\r\n\tmovss xmm0, [ray_pos]\r\n\tmovss xmm1, [ray_pos+4]\r\n\tmovss xmm2, [ray_pos+8]\r\n\tcvtss2sd xmm0, xmm0 ; convert to double for printf\r\n\tcvtss2sd xmm1, xmm1 ; convert to double for printf\r\n\tcvtss2sd xmm2, xmm2 ; convert to double for printf\r\n        lea rdi, [ray_debug]\r\n\tmov eax, 3\r\n        ;call printf\r\n\r\n\tcall get_sdf\r\n\tcvtss2sd xmm0, xmm0\r\n\tlea rdi, [sdf_debug]\r\n\tmov eax, 1\r\n\t;call printf\r\n\r\n\tret\r\n\r\nmarch_ray:\r\n\r\n\tcall get_sdf\r\n\tmovss xmm1, [ray_dst]\r\n\taddss xmm1, xmm0\r\n\tmovss [ray_dst], xmm1 ; acc ray_dst\r\n\t\r\n\tmovss xmm1, [ray_dir] ; load ray_dir\r\n\tmovss xmm2, [ray_dir+4]\r\n\tmovss xmm3, [ray_dir+8]\r\n\r\n\tmulss xmm1, xmm0 ; multiply ray_dir by sdf\r\n\tmulss xmm2, xmm0\t\r\n\tmulss xmm3, xmm0\r\n\r\n\tmovss xmm0, [ray_pos] ; mod ray_pos 0\r\n\taddss xmm0, xmm1\r\n\tmovss xmm1, [space_wrap]\r\n\tcall mod\r\n\tmovss [ray_pos], xmm0\r\n\r\n\tmovss xmm0, [ray_pos+4] ; mod ray_pos 4\r\n\taddss xmm0, xmm2\r\n\tmovss xmm1, [space_wrap]\r\n\tcall mod\r\n\tmovss [ray_pos+4], xmm0\r\n\r\n\tmovss xmm0, [ray_pos+8]\r\n\taddss xmm0, xmm3\r\n\tmovss xmm1, [space_wrap]\r\n\tcall mod\r\n\tmovss [ray_pos+8], xmm0\r\n\r\n\tret\r\n\r\nget_sdf: ; returns sdf to xmm0\r\n\t\r\n\tmovss xmm0, [ray_pos] ; load values for get_dist\r\n\tmovss xmm1, [ray_pos+4]\r\n\tmovss xmm2, [ray_pos+8]\r\n\tmovss xmm3, [sp_pos]\r\n\tmovss xmm4, [sp_pos+4]\r\n\tmovss xmm5, [sp_pos+8]\r\n\r\n\tcall get_dist\r\n\r\n\tmovss xmm1, [sp_rad]\r\n\tsubss xmm0, xmm1\r\n\r\n\tret\r\n\r\nget_dist: ; returns dist to xmm0 from xmm0-5\r\n\r\n\tsubss xmm0, xmm3 ; get differences\r\n\tsubss xmm1, xmm4\r\n\tsubss xmm2, xmm5\r\n\r\n\tmulss xmm0, xmm0 ; square differences\r\n\tmulss xmm1, xmm1\r\n\tmulss xmm2, xmm2\r\n\r\n\taddss xmm0, xmm1 ; sum squares\r\n\taddss xmm0, xmm2\r\n\r\n\tsqrtss xmm0, xmm0 ; sqrt sum\r\n\r\n\tret\r\n\r\nmod: ; xmm0 mod xmm1\r\n\r\n\tsub rsp, 48\r\n\tmovaps [rsp], xmm1\r\n\tmovaps [rsp+16], xmm2\r\n\tmovaps [rsp+32], xmm3\r\n\t\r\n\tmovss xmm3, xmm0\r\n\tdivss xmm0, xmm1\r\n\troundss xmm2, xmm0, 1\r\n\tmulss xmm2, xmm1\r\n\tmovss xmm0, xmm3\r\n\tsubss xmm0, xmm2\r\n\r\n\tmovaps xmm3, [rsp+32]\r\n\tmovaps xmm2, [rsp+16]\r\n\tmovaps xmm1, [rsp]\r\n\tadd rsp, 48\r\n\r\n\tret'},
	{ type: 'javascript', content: 'const fs = require(\'node:fs\');\r\nconst readline = require(\'readline\');\r\n\r\nconst rl = readline.createInterface({\r\n\tinput: process.stdin,\r\n\toutput: process.stdout,\r\n});\r\n\r\nvar lang = {};\r\nvar lineDelim = \";\"\r\nclass Token { \/\/token class\r\n        constructor(type, value) {\r\n                this.type = type;\r\n                this.value = value;\r\n        }\r\n}\r\n\r\nfs.readFile(process.argv[2], \'utf8\', (err, data) => { \/\/read file\r\n\tif (err) {\r\n\t\tconsole.error(err);\r\n\t\treturn;\r\n\t}\r\n\tlang.eval(data, false); \/\/evaluate file\r\n});\r\nlang.eval = async function(code, debug) { \/\/eval function\r\n\tvar tokens = lang.tokenize(code, debug);\r\n\tif (debug) console.log(tokens);\r\n\t\r\n\tvar ast = lang.parse(tokens, debug);\r\n\tif (debug) console.log(JSON.stringify(ast, null, 2));\r\n\r\n\tvar substack = [];\r\n\tvar variables = {};\r\n\tvar currentLine = 0;\r\n\t\r\n\tfunction getUserInput() {\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tif (!rl) {\r\n\t\t\t\treject(\'Readline interface is not initialized.\');\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\trl.question(\'\', (input) => {\r\n\t\t\t\tif (input === undefined || input === null) {\r\n\t\t\t\t\treject(\'Input was undefined or null.\');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresolve(input.trim());\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\tasync function evalLine(line) {\r\n\t\tif (line.type != \'line\') throw `Expected line got ${line.type}`;\r\n\t\tawait evalStatement(line.statement);\r\n\t}\r\n\r\n\tasync function evalStatement(statement) {\r\n\t\tif (debug) console.log(`evaluating statement ${statement.type}`);\r\n\t\tif (statement.type == \'if\') {\r\n\t\t\tvar left = Number(evalExpression(statement.expressionL));\r\n\t\t\tvar right = Number(evalExpression(statement.expressionR));\r\n\t\t\tvar relop = statement.relop.value;\r\n\t\t\tvar condition = false;\r\n\t\t\tif (relop == \'=\') {\r\n\t\t\t\tcondition = left == right;\r\n\t\t\t} else if (relop == \'<>\') {\r\n\t\t\t\tcondition = left != right;\r\n\t\t\t} else if (relop == \'>\') {\r\n\t\t\t\tcondition = left > right;\r\n\t\t\t} else if (relop == \'<\') {\r\n\t\t\t\tcondition = left < right;\r\n\t\t\t} else if (relop == \'<=\') {\r\n\t\t\t\tcondition = left <= right;\r\n\t\t\t} else if (relop == \'>=\') {\r\n\t\t\t\tcondition = left >= right;\r\n\t\t\t}\r\n\t\t\tif (debug) console.log(`if condition determined to be ${condition} (${left} ${relop} ${right})`)\r\n\t\t\tif (condition) {\r\n\t\t\t\tif (debug) console.log(`evaluating substatement`);\r\n\t\t\t\tevalStatement(statement.statement);\r\n\t\t\t}\r\n\t\t} else if (statement.type == \'print\') {\r\n\t\t\tvar exprs = statement.exprList.exprs;\r\n\t\t\tvar log = \"\";\r\n\t\t\tfor (var i = 0; i < exprs.length; i++) {\r\n\t\t\t\tvar expr = exprs[i];\r\n\t\t\t\tif (expr.type == \'STRING\') log += expr.value.slice(1, -1); \/\/remove quotes\r\n\t\t\t\telse log += String(evalExpression(expr));\r\n\t\t\t}\r\n\t\t\tconsole.log(log);\r\n\t\t} else if (statement.type == \'goto\') {\r\n\t\t\tvar target = evalExpression(statement.expression);\r\n\t\t\tvar line = ast.filter(e => e.number && e.number.value == String(target));\r\n\t\t\tif (line.length != 1) {\r\n\t\t\t\tif (line.length == 0) throw `Could not goto line ${target} at ${statement.line}:${statement.col} - no such line exists`;\r\n\t\t\t\telse throw `Could not goto line ${target} at ${statement.line}:${statement.col} - found ${line.length} occourances of line`;\r\n\t\t\t}\r\n\t\t\tcurrentLine = ast.indexOf(line[0]) - 1;\r\n\t\t\tif (debug) console.log(`set currentLine to ${currentLine} : (target ${target})`);\r\n\t\t} else if (statement.type == \'gosub\') {\r\n\t\t\tvar target = evalExpression(statement.expression);\r\n\t\t\tvar line = ast.filter(e => e.number && e.number.value == String(target));\r\n\t\t\tif (line.length != 1) {\r\n\t\t\t\tif (line.length == 0) throw `Could not gosub line ${target} at ${statement.line}:${statement.col} - no such line exists`;\r\n\t\t\t\telse throw `Could not gosub line ${target} at ${statement.line}:${statement.col} - found ${line.length} occourances of line`;\r\n\t\t\t}\r\n\t\t\tsubstack.push(currentLine);\r\n\t\t\tcurrentLine = ast.indexOf(line[0]) - 1;\r\n\t\t\tif (debug) console.log(`set currentLine to ${currentLine} : (target ${target}) with stack ${substack}`);\r\n\t\t} else if (statement.type == \'input\') {\r\n\t\t\tvar varList = statement.varList.vars;\r\n\t\t\tfor (var i = 0; i < varList.length; i++) {\r\n\t\t\t\tvar variable = varList[i];\r\n\t\t\t\tif (debug) console.log(`attempting to await for user input..`);\r\n\t\t\t\tconst input = await getUserInput();\r\n\t\t\t\tif (debug) console.log(`Got user input ${input}`);\r\n\t\t\t\tif (isNaN(input)) {\r\n\t\t\t\t\tthrow `Invalid input for ${variable.value}. Expected a number.`;\r\n\t\t\t\t}\r\n\t\t\t\tvariables[variable.value] = Number(input);\r\n\t\t\t\tif (debug) console.log(`set ${variable.value} to ${Number(input)}`);\r\n\t\t\t}\r\n\t\t} else if (statement.type == \'let\') {\r\n\t\t\tvariables[statement.variable.value] = evalExpression(statement.expression);\r\n\t\t\tif (debug) console.log(`set ${statement.variable.value} to ${variables[statement.variable.value]}`);\r\n\t\t} else if (statement.type == \'return\') {\r\n\t\t\tif (substack.length == 0) throw `Cannot RETURN to empty substack, instead try using END`;\r\n\t\t\tcurrentLine = substack.pop();\r\n\t\t\tif (debug) console.log(`returned currentLine to ${currentLine} with stack ${substack}`);\r\n\t\t} else if (statement.type == \'end\') {\r\n\t\t\tcurrentLine = ast.length;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction evalExpression(expression) {\r\n\t\tif (expression.type == \'NUMBER\') {\r\n\t\t\treturn expression.value;\r\n\t\t} else if (expression.type == \'VARIABLE\') {\r\n\t\t\tif (debug) console.log(`expression: returning variable ${expression.value} with variables of ${JSON.stringify(variables)}`)\r\n\t\t\tif (debug) console.log(`${variables[expression.value]}`);\r\n\t\t\tvar val = variables[expression.value];\r\n\t\t\treturn val || 0;\r\n\t\t} else if (expression.type == \'binaryExpression\') {\r\n\t\t\tconst left = Number(evalExpression(expression.left));\r\n\t\t\tconst right = Number(evalExpression(expression.right));\r\n\t\t\tconst op = expression.operator;\r\n\t\t\tif (op == \'+\') {\r\n\t\t\t\treturn left + right;\r\n\t\t\t} else if (op == \'-\') {\r\n\t\t\t\treturn left - right;\r\n\t\t\t} else if (op == \'*\') {\r\n\t\t\t\treturn left * right;\r\n\t\t\t} else if (op == \'\/\') {\r\n\t\t\t\treturn ~~(left \/ right); \/\/truncate division\r\n\t\t\t}\r\n\t\t} else if (expression.type == \'group\') {\r\n\t\t\treturn evalExpression(expression.expression);\r\n\t\t}\r\n\t}\r\n\r\n\tasync function execute() {\r\n\t\twhile (currentLine < ast.length) {\r\n\t\t\tconst line = ast[currentLine];\r\n\t\t\tawait evalLine(line);\r\n\t\t\tcurrentLine++;\r\n\t\t}\r\n\t\trl.close();\r\n\t}\r\n\r\n\texecute().catch((error) => {\r\n\t\tconsole.error(\'Error during evaluation:\', error);\r\n\t});\r\n}\r\n\r\nlang.parse = function(tokens, debug) { \/\/parser function\r\n\tvar current = 0;\r\n\r\n\ttokens = tokens.filter(e => e.type != \'REM\');\r\n\r\n\tfor (var i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == \'NEWLINE\') {\r\n\t\t\tif (tokens[i+1] && tokens[i+1].type == \'NEWLINE\') {\r\n\t\t\t\ttokens.splice(i + 1, 1); \/\/remove double newlines\r\n\t\t\t\ti--;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (debug) console.log(\"Sanitized tokens:\\n\", tokens);\r\n\r\n\tfunction peek() {\r\n\t\treturn tokens[current];\r\n\t}\r\n\r\n\tfunction consume(type) {\r\n\t\tconst token = peek();\r\n\t\tif (token.type == type) {\r\n\t\t\tcurrent++;\r\n\t\t\treturn token;\r\n\t\t} else {\r\n\t\t\tthrow `Expecting token of type ${type} but found ${token.type}`;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parseLine() {\r\n\t\tvar number = null;\r\n\t\tif (peek().type == \'NEWLINE\') {\r\n\t\t\tconsume(\'NEWLINE\');\r\n\t\t\treturn parseLine();\r\n\t\t}\r\n\t\tif (peek().type == \'NUMBER\') {\r\n\t\t\tnumber = consume(\'NUMBER\');\r\n\t\t}\r\n\t\tconst statement = parseStatement();\r\n\t\tconsume(\'NEWLINE\');\r\n\t\treturn {\r\n\t\t\ttype: \'line\',\r\n\t\t\tnumber,\r\n\t\t\tstatement,\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parseStatement() {\r\n\t\tconst token = peek();\r\n\t\tif (token.type != \'KEYWORD\') throw `Expecting keyword instead found ${token.type} of value ${token.value}`;\r\n\t\tconsume(\'KEYWORD\');\r\n\t\tswitch (token.value) {\r\n\t\t\tcase \'PRINT\': {\r\n\t\t\t\tconst exprList = parseExprList();\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \'print\',\r\n\t\t\t\t\texprList,\r\n\t\t\t\t\tline: token.line,\r\n\t\t\t\t\tcol: token.col,\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase \'IF\': {\r\n\t\t\t\tconst expressionL = parseExpression();\r\n\t\t\t\tconst relop = consume(\'RELOP\');\r\n\t\t\t\tconst expressionR = parseExpression();\r\n\t\t\t\tif (peek().value != \'THEN\') throw \'Expecting THEN after IF conditional\';\r\n\t\t\t\tconsume(\'KEYWORD\');\r\n\t\t\t\tconst statement = parseStatement();\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \'if\',\r\n\t\t\t\t\texpressionL,\r\n\t\t\t\t\trelop,\r\n\t\t\t\t\texpressionR,\r\n\t\t\t\t\tstatement,\r\n\t\t\t\t\tline: token.line,\r\n\t\t\t\t\tcol: token.col,\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase \'GOTO\': {\r\n\t\t\t\tconst expression = parseExpression();\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \'goto\',\r\n\t\t\t\t\texpression,\r\n\t\t\t\t\tline: token.line,\r\n\t\t\t\t\tcol: token.col,\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase \'GOSUB\': {\r\n\t\t\t\tconst expression = parseExpression();\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \'gosub\',\r\n\t\t\t\t\texpression,\r\n\t\t\t\t\tline: token.line,\r\n\t\t\t\t\tcol: token.col,\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase \'INPUT\': {\r\n\t\t\t\tconst varList = parseVarList();\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \'input\',\r\n\t\t\t\t\tvarList,\r\n\t\t\t\t\tline: token.line,\r\n\t\t\t\t\tcol: token.col,\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase \'LET\': {\r\n\t\t\t\tconst variable = consume(\'VARIABLE\');\r\n\t\t\t\tif (peek().value != \'=\') throw \'Expected = after variable name for LET statement\';\r\n\t\t\t\tconsume(\'RELOP\');\r\n\t\t\t\tconst expression = parseExpression();\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \'let\',\r\n\t\t\t\t\tvariable,\r\n\t\t\t\t\texpression,\r\n\t\t\t\t\tline: token.line,\r\n\t\t\t\t\tcol: token.col,\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase \'RETURN\': {\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \'return\',\r\n\t\t\t\t\tline: token.line,\r\n\t\t\t\t\tcol: token.col,\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase \'END\': {\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \'end\',\r\n\t\t\t\t\tline: token.line,\r\n\t\t\t\t\tcol: token.col,\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdefault: {\r\n\t\t\t\tthrow `${token.value} has not been implemented`;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parseExprList() {\r\n\t\tvar exprs = [];\r\n\r\n\t\tvar cont = true;\r\n\t\twhile (cont) {\r\n\t\t\tif (peek().type == \'STRING\') {\r\n\t\t\t\texprs.push(consume(\'STRING\'));\r\n\t\t\t} else {\r\n\t\t\t\texprs.push(parseExpression());\r\n\t\t\t}\r\n\t\t\tif (peek().value != \',\') cont = false;\r\n\t\t\telse consume(\'OPERATOR\');\r\n\t\t}\r\n\t\treturn {\r\n\t\t\ttype: \'exprList\',\r\n\t\t\texprs,\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parseVarList() {\r\n\t\tvar vars = [];\r\n\r\n\t\tvar cont = true;\r\n\t\twhile(cont) {\r\n\t\t\tvars.push(consume(\'VARIABLE\'));\r\n\t\t\tif (peek().value != \',\') cont = false;\r\n\t\t\telse consume(\'OPERATOR\');\r\n\t\t}\r\n\t\treturn {\r\n\t\t\ttype: \'varList\',\r\n\t\t\tvars,\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parseExpression() {\r\n\t\tvar node = parseTerm();\r\n\t\twhile (peek() && peek().value == \"+\" || peek().value == \"-\") {\r\n\t\t\tconst operator = consume(\'OPERATOR\');\r\n\t\t\tconst right = parseTerm();\r\n\t\t\tnode = { type: \'binaryExpression\', operator: operator.value, left: node, right };\r\n\t\t}\r\n\t\treturn node;\r\n\t}\r\n\r\n\tfunction parseTerm() {\r\n\t\tvar node = parseFactor();\r\n\t\twhile (peek() && peek().value == \"*\" || peek().value == \"\/\") {\r\n\t\t\tconst operator = consume(\'OPERATOR\');\r\n\t\t\tconst right = parseFactor();\r\n\t\t\tnode = { type: \'binaryExpression\', operator: operator.value, left: node, right };\r\n\t\t}\r\n\t\treturn node;\r\n\t}\r\n\r\n\tfunction parseFactor() {\r\n\t\tconst token = peek();\r\n\r\n\t\tswitch (token.type) {\r\n\t\t\tcase \'NUMBER\':\r\n\t\t\t\tconsume(\'NUMBER\');\r\n\t\t\t\treturn token;\r\n\t\t\tcase \'VARIABLE\':\r\n\t\t\t\tconsume(\'VARIABLE\');\r\n\t\t\t\treturn token;\r\n\t\t\tcase \'GROUPING\':\r\n\t\t\t\tif (token.value != \'(\') throw `Mismatched parentheses [expected ( got ${token.value}] at ${token.line}:${token.col}`;\r\n\t\t\t\tconsume(\'GROUPING\');\r\n\t\t\t\tconst expression = parseExpression();\r\n\t\t\t\tconst closingParen = peek();\r\n\t\t\t\tif (closingParen.value != \')\') throw `Mismatched parenthesis [expected ) got ${closingParen.value}] at ${closingParen.line}:${closingParen.col}`;\r\n\t\t\t\tconsume(\'GROUPING\');\r\n\t\t\t\treturn { type: \'group\', expression };\r\n\t\t\tdefault:\r\n\t\t\t\tthrow `Unexpected type for factor, expected NUMBER|VARIABLE|GROUPING got ${token.type} of ${token.value}`;\r\n\t\t}\r\n\t}\r\n\r\n\tvar lines = [];\r\n\twhile (current < tokens.length) {\r\n\t\tlines.push(parseLine());\r\n\t}\r\n\treturn lines;\r\n}\r\n\r\nlang.tokenize = function(code, debug) { \/\/tokenize function\r\n        var tokens = [];\r\n        const tokenSpec = [\r\n\t\t{ type: \'NEWLINE\', regex: \/\\n\/ },\r\n\t\t{ type: \'KEYWORD\', regex: \/THEN|END|GOTO|IF|PRINT|RETURN|LET|INPUT|GOSUB\/ },\r\n\t\t{ type: \'RELOP\', regex: \/>=|<=|<>|[<>=]\/},\r\n\t\t{ type: \'OPERATOR\', regex: \/[+\\-*,\\\/]\/ },\r\n\t\t{ type: \'GROUPING\', regex: \/[()]\/ },\r\n\t\t{ type: \'NUMBER\', regex: \/[0-9]+\/ },\r\n\t\t{ type: \'STRING\', regex: \/\\\"[^\"]*\\\"\/ },\r\n\t\t{ type: \'REM\', regex: \/REM.*\/ },\r\n\t\t{ type: \'VARIABLE\', regex: \/[A-Z]\/ },\r\n\t\t{ type: \'WHITESPACE\', regex: \/[ \\t]+\/ },\r\n        ];\r\n        let pos = 0;\r\n\tlet line = 0;\r\n\tlet col = 0;\r\n        while (pos < code.length) {\r\n                let match = null;\r\n                for (let { type, regex } of tokenSpec) {\r\n                        match = regex.exec(code.slice(pos));\r\n                        if (match && match.index === 0) {\r\n                                if (type !== \'WHITESPACE\') {\r\n                                        tokens.push({ type, value: match[0], line, col });\r\n                                }\r\n                                pos += match[0].length;\r\n\t\t\t\tif (type === \'NEWLINE\') {\r\n\t\t\t\t\tcol = 0;\r\n\t\t\t\t\tline++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcol += match[0].length;\r\n\t\t\t\t}\r\n                                break;\r\n                        }\r\n                }\r\n                \/\/if (debug) console.log(match);\r\n\r\n                if (!match || match.index !== 0) {\r\n                        throw new Error(`Unexpected token at position ${pos}: \'${code[pos]}\'`);\r\n                }\r\n        }\r\n        return tokens;\r\n}' },
	{ type: 'c', content: '#include <stdio.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdlib.h>\r\n\r\ntypedef enum {\r\n\tTOKEN_PLUS,\r\n\tTOKEN_ASTERISK,\r\n\tTOKEN_WILDCARD,\r\n\tTOKEN_LITERAL,\r\n\tTOKEN_ALTERNATOR,\r\n\tTOKEN_LPAREN,\r\n\tTOKEN_RPAREN,\r\n\tTOKEN_LBRACK,\r\n\tTOKEN_RBRACK,\r\n\tTOKEN_LBRACE,\r\n\tTOKEN_RBRACE,\r\n\tTOKEN_COMMA,\r\n\tTOKEN_EOF,\r\n\tTOKEN_ESCAPE_SEQUENCE,\r\n\tTOKEN_CARET,\r\n\tTOKEN_QUESTION,\r\n\tTOKEN_DOLLAR,\r\n} TokenType;\r\n\r\ntypedef struct {\r\n\tTokenType type;\r\n\tchar* value;\r\n} Token;\r\n\r\ntypedef enum {\r\n\tNODE_LITERAL,\t\t\/\/single character and escape\r\n\tNODE_ALTERNATION,\t\/\/(a|b)\r\n\tNODE_SUBEXPRESSION,\r\n\tNODE_REPETITION,\t\/\/(*, +, ?, {n,m})\r\n\tNODE_GROUP,\t\t\/\/()\r\n\tNODE_CHARACTER_CLASS,\t\/\/[a-z] [abc] etc..\r\n\tNODE_WILDCARD,\t\t\/\/.\r\n\tNODE_NEGATED_CLASS,\t\/\/[^abc]\r\n\tNODE_REGEX,\t\t\/\/entire expression\r\n\tNODE_EXPRESSION,\r\n\tNODE_MATCH,\r\n\tNODE_ATOM,\r\n} NodeType;\r\n\r\ntypedef struct ASTNode {\r\n\tNodeType type;\r\n\tToken *value;\r\n\tint minRepetitions;\r\n\tint maxRepetitions;\r\n\tstruct ASTNode *left;\r\n\tstruct ASTNode *right;\r\n} ASTNode;\r\n\r\nToken* Tokenize(const char *regex, int *tokCount) {\r\n\tconst char *p = regex;\r\n\tint length = strlen(regex);\r\n\t*tokCount = 0;\r\n\tToken* tokens = malloc(sizeof(Token) * length); \/\/cannot have more tokens than regex characters (i think?)\r\n\tToken *tok = tokens;\r\n\twhile (*p) {\r\n\t\tif (*p == \'*\') {\r\n\t\t\t\/\/printf(\"TOKEN_ASTERISK : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_ASTERISK;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \'+\') {\r\n\t\t\t\/\/printf(\"TOKEN_PLUS : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_PLUS;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \'^\') {\r\n\t\t\t\/\/printf(\"TOKEN_CARET : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_CARET;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \'$\') {\r\n\t\t\t\/\/printf(\"TOKEN_DOLLAR : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_DOLLAR;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t}else if (*p == \'.\') {\r\n\t\t\t\/\/printf(\"TOKEN_WILDCARD : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_WILDCARD;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \'?\') {\r\n\t\t\t\/\/printf(\"TOKEN_QUESTION : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_QUESTION;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \'|\') {\r\n\t\t\t\/\/printf(\"TOKEN_ALTERNATOR : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_ALTERNATOR;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \'(\') {\r\n\t\t\t\/\/printf(\"TOKEN_LPAREN : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_LPAREN;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \')\') {\r\n\t\t\t\/\/printf(\"TOKEN_RPAREN : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_RPAREN;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \'[\') {\r\n\t\t\t\/\/printf(\"TOKEN_LBRACK : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_LBRACK;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \']\') {\r\n\t\t\t\/\/printf(\"TOKEN_RBRACK : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_RBRACK;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \'{\') {\r\n\t\t\t\/\/printf(\"TOKEN_LBRACE : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_LBRACE;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \'}\') {\r\n\t\t\t\/\/printf(\"TOKEN_RBRACE : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_RBRACE;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \',\') {\r\n\t\t\t\/\/printf(\"TOKEN_COMMA : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_COMMA;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t} else if (*p == \'\\\\\') {\r\n\t\t\t\/\/printf(\"TOKEN_ESCAPE_SEQUENCE : %c%c\\n\", *p, *(p+1));\r\n\t\t\ttok->type = TOKEN_ESCAPE_SEQUENCE;\r\n\t\t\ttok->value = malloc(3);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\tp++;\r\n\t\t\ttok->value[1] = *p;\r\n\t\t\ttok->value[2] = \'\\0\';\r\n\t\t} else if (*p != \'\/\') {\r\n\t\t\t\/\/printf(\"TOKEN_LITERAL : %c\\n\", *p);\r\n\t\t\ttok->type = TOKEN_LITERAL;\r\n\t\t\ttok->value = malloc(2);\r\n\t\t\ttok->value[0] = *p;\r\n\t\t\ttok->value[1] = \'\\0\';\r\n\t\t}\r\n\t\tp++;\r\n\t\ttok++;\r\n\t\t(*tokCount)++;\r\n\t}\r\n\ttokens = realloc(tokens, *tokCount * sizeof(Token));\r\n\treturn tokens;\r\n}\r\n\r\nconst Token *Peek(const Token* tokens, int *position) {\r\n\treturn &tokens[*position];\r\n}\r\n\r\nconst Token *Consume(TokenType type, const Token* tokens, int *position) {\r\n\tif (Peek(tokens, position)->type == type) {\r\n\t\treturn &tokens[(*position)++];\r\n\t} else {\r\n\t\tprintf(\"Tried to consume token of type %d but found %d\", type, Peek(tokens, position)->type);\r\n\t\texit(1);\r\n\t}\r\n}\r\n\r\nASTNode *ConsumeExpression(const Token* tokens, int tokenCount, int *position);\r\n\r\nASTNode *MakeAtom(const Token* token) {\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tnode->type = NODE_ATOM;\r\n\tnode->value = token;\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeGroupInner(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\t\/\/check GroupNonCapturingModifier\r\n\tToken* token = Peek(tokens, position);\r\n\tif (token->type == TOKEN_QUESTION) {\r\n\t\tConsume(TOKEN_QUESTION, tokens, position);\r\n\t\ttoken = Peek(tokens, position);\r\n\t\tif (token->value[0] == \':\') {\r\n\t\t\ttoken->left = MakeAtom(Consume(TOKEN_LITERAL, tokens, position));\r\n\t\t} else {\r\n\t\t\tprintf(\"expected ?: for group noncapturing modifier\");\r\n\t\t\texit(1);\r\n\t\t}\r\n\t}\r\n\tnode->right = ConsumeExpression(tokens, tokenCount, position);\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeGroup(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tToken* token = Peek(tokens, position);\r\n\tif (token->type != TOKEN_LPAREN) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\tConsume(TOKEN_LPAREN, tokens, position);\r\n\tnode->left = ConsumeGroupInner(tokens, tokenCount, position);\r\n\tif (node->left == NULL) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\ttoken = Peek(tokens, position);\r\n\tif (token->type != TOKEN_RPAREN) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\tConsume(TOKEN_RPAREN, tokens, position);\r\n\tnode->right = ConsumeQuantifier(tokens, tokenCount, position); \/\/optional\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeAnchor(const Token* tokens, int tokenCount, int *position) {\t\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tToken* token = Peek(tokens, position);\r\n\tif (token->type != TOKEN_ESCAPE_SEQUENCE && token->type != TOKEN_DOLLAR) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\tif (token->type == TOKEN_DOLLAR) {\r\n\t\tnode->value = Consume(TOKEN_DOLLAR, tokens, position);\r\n\t\treturn node;\r\n\t}\r\n\tchar c = token->value[1];\r\n\tif (c == \'b\' || c == \'B\' || c == \'A\' || c == \'z\' || c == \'Z\' || c == \'G\') {\r\n\t\tnode->value = Consume(TOKEN_ESCAPE_SEQUENCE, tokens, position);\r\n\t\treturn node;\r\n\t}\r\n\tfree(node);\r\n\t*position = startPos;\r\n\treturn NULL;\r\n}\r\n\r\nASTNode *ConsumeQuantifier(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tToken* token = Peek(tokens, position);\r\n\tif (token->type != TOKEN_ASTERISK && token->type != TOKEN_PLUS && token->type != TOKEN_QUESTION) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\tif (token->type == TOKEN_ASTERISK) {\r\n\t\tnode->left = MakeAtom(Consume(TOKEN_ASTERISK, tokens, position));\r\n\t} else if (token->type == TOKEN_PLUS) {\r\n\t\tnode->left = MakeAtom(Consume(TOKEN_PLUS, tokens, position));\r\n\t} else if (token->type == TOKEN_QUESTION) {\r\n\t\tnode->left = MakeAtom(Consume(TOKEN_QUESTION, tokens, position));\r\n\t}\r\n\ttoken = Peek(tokens, position);\r\n\tif (token->type == TOKEN_QUESTION) {\r\n\t\tnode->right = MakeAtom(Consume(TOKEN_QUESTION, tokens, position));\r\n\t}\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeCharacterRange(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tToken* token = Peek(tokens, position);\r\n\tif (token->type != TOKEN_LITERAL) {\r\n\t\tfree(node);\r\n\t\treturn NULL;\r\n\t}\r\n\tnode->left = MakeAtom(Consume(TOKEN_LITERAL, tokens, position));\r\n\ttoken = Peek(tokens, position);\r\n\tif (token->value[0] != \'-\') {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\tConsume(TOKEN_LITERAL, tokens, position);\r\n\ttoken = Peek(tokens, position);\r\n\tif (token->type != TOKEN_LITERAL) {\r\n\t\tfree(node->left);\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\tnode->right = MakeAtom(Consume(TOKEN_LITERAL, tokens, position));\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeCharacterClass(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tToken* token = Peek(tokens, position);\r\n\tif (token->type == TOKEN_ESCAPE_SEQUENCE) {\r\n\t\tchar c = token->value[1];\r\n\t\tif (c == \'w\' || c == \'W\' || c == \'d\' || c == \'D\') {\r\n\t\t\tnode->value = token;\r\n\t\t\treturn node;\r\n\t\t}\r\n\t}\r\n\tfree(node);\r\n\t*position = startPos;\r\n\treturn NULL;\r\n}\r\n\r\nASTNode *ConsumeCharacterGroupItem(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tnode = ConsumeCharacterClass(tokens, tokenCount, position);\r\n\tif (!node) node = ConsumeCharacterRange(tokens, tokenCount, position);\r\n\tToken* token = Peek(tokens, position);\r\n\tif (token->type == TOKEN_RBRACK) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t} else if (token->type == TOKEN_LITERAL) {\r\n\t\tnode = Consume(TOKEN_LITERAL, tokens, position);\r\n\t} else {\r\n\t\tprintf(\"whoops something has gone wrong\");\r\n\t\texit(1);\r\n\t}\r\n\tif (!node) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeCharacterGroupItemList(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tnode->left = ConsumeCharacterGroupItem(tokens, tokenCount, position);\r\n\tif (!node->left) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\tnode->right = ConsumeCharacterGroupItemList(tokens, tokenCount, position);\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeCharacterGroup(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tToken* token = Peek(tokens, position);\r\n\tif (token->type != TOKEN_LBRACK) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tConsume(TOKEN_LBRACK, tokens, position);\r\n\ttoken = Peek(tokens, position);\r\n\tif (token->type == TOKEN_CARET) {\r\n\t\tnode->left = Consume(TOKEN_CARET, tokens, position); \/\/ 0 or 1\r\n\t}\r\n\tnode->right = ConsumeCharacterGroupItemList(tokens, tokenCount, position); \/\/ required\r\n\tif (!node->right) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeMatchCharacterClass(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tnode = ConsumeCharacterGroup(tokens, tokenCount, position);\r\n\tif (!node) node = ConsumeCharacterClass(tokens, tokenCount, position);\r\n\tif (!node) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeMatchCharacter(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tToken* token = Peek(tokens, position);\r\n\tif (token->type == TOKEN_LITERAL) {\r\n\t\treturn Consume(TOKEN_LITERAL, tokens, position);\r\n\t}\r\n\t*position = startPos;\r\n\treturn NULL;\r\n}\r\n\r\nASTNode *ConsumeMatchItem(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tif (Peek(tokens, position)->type == TOKEN_WILDCARD) {\r\n\t\tnode->value = Consume(TOKEN_WILDCARD, tokens, position);\r\n\t\tnode->type = NODE_WILDCARD;\r\n\t}\r\n\tif (!node->value) node = ConsumeMatchCharacterClass(tokens, tokenCount, position);\r\n\tif (!node) node = ConsumeMatchCharacter(tokens, tokenCount, position);\r\n\tif (!node) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeMatch(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tnode->left = ConsumeMatchItem(tokens, tokenCount, position);\r\n\tnode->right = ConsumeQuantifier(tokens, tokenCount, position);\r\n\tnode->type = NODE_MATCH;\r\n\tif (!node->left) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeSubExpressionItem(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tnode = ConsumeMatch(tokens, tokenCount, position);\r\n\tif (!node) node = ConsumeGroup(tokens, tokenCount, position);\r\n\tif (!node) node = ConsumeAnchor(tokens, tokenCount, position);\r\n\tif (!node) node = ConsumeBackreference(tokens, tokenCount, position);\r\n\tif (!node) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeSubExpression(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tnode->type = NODE_SUBEXPRESSION;\r\n\tnode->left = ConsumeSubExpressionItem(tokens, tokenCount, position);\r\n\tif (!node->left) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\tnode->right = ConsumeSubExpression(tokens, tokenCount, position);\r\n\treturn node;\r\n}\r\n\r\nASTNode *ConsumeExpression(const Token* tokens, int tokenCount, int *position) {\r\n\tint startPos = *position;\r\n\tif (*position >= tokenCount) {\r\n\t\treturn NULL;\r\n\t}\r\n\tASTNode *node = malloc(sizeof(ASTNode));\r\n\tnode->type = NODE_EXPRESSION;\r\n\tnode->left = ConsumeSubExpression(tokens, tokenCount, position);\r\n\tif (!node->left) {\r\n\t\tfree(node);\r\n\t\t*position = startPos;\r\n\t\treturn NULL;\r\n\t}\r\n\tif (Peek(tokens, position)->type == TOKEN_ALTERNATOR) {\r\n\t\tConsume(TOKEN_ALTERNATOR, tokens, position);\r\n\t\tnode->right = ConsumeExpression(tokens, tokenCount, position);\r\n\t}\r\n\treturn node;\r\n}\r\n\r\nASTNode *Parse(const Token* tokens, int tokenCount) { \/\/shoutout https:\/\/github.com\/kean\/Regex\/blob\/main\/grammar.ebnf\r\n\tconst Token* token = tokens;\r\n\tASTNode *regex = malloc(sizeof(ASTNode));\r\n\tint position = 0;\r\n\tregex->type = NODE_REGEX;\r\n\tregex->left = ConsumeExpression(tokens, tokenCount, &position);\r\n\treturn regex;\r\n}\r\n\r\nint main() {\r\n\t\/\/const char *regex = \"\\\\\/\\\\*\\\\*.*?[^\\\\\/]\\\\*\\\\*\\\\\/\"; \/\/ regex for matching multiline comments in \/** **\/ form\r\n\tconst char *regex = \"\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}\"; \/\/ regex for matching phone numbers\r\n\tint tokenCount = 0;\r\n\tconst Token* tokens = Tokenize(regex, &tokenCount);\r\n\tfor (int i = 0; i < tokenCount; i++) {\r\n\t\tprintf(\"Token %d; %s\\n\", i, tokens[i].value);\r\n\t}\r\n\tASTNode *parsedRegex = Parse(tokens, tokenCount);\r\n}' },

]
